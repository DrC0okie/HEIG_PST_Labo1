---
title: "HEIG_PST_Labo1"
author: "Timothée Van Hove"
format: html
editor: visual
---

## Introduction

Dans ce rapport, les questions et parties issues de la consigne fournir sont représentées par des citations.

## Exercice 1

> a.  Les données se trouvent dans le répertoire data /data
> b.  Charger les données dans R en utilisant les fonctions `scan()` et `read.table()`

```{r}
cpus <- scan("data/cpus.txt")
examen <- read.table("data/examen.txt", header = TRUE)

```

> c.  Pour voir le contenu de l'objet cpus, taper l'instruction `cpus`

```{r}
cpus
```

```{r}
examen
```

> d.  Pour accéder à la 12ème composante du vecteur `cpus`, utiliser la commande

```{r}
cpus[12]
```

> e.  Pour obtenir une partie du vecteur `cpus` comme par exemple les éléments du vecteur compris entre la 3ème et la 19ème composante, taper l'instruction

```{r}
cpus[3:19]
```

> f.  Pour extraire du vecteur `cpus` ses éléments supérieurs à 190, utiliser la commande

```{r}
cpus[cpus>190]
```

> g.  Il est possible d'accéder directement aux composantes d'une table par le nom. Par exemple, si on veut afficher la composante `note` de l'objet `examen`, on peut utiliser la commande

```{r}
examen$note
```

> h.  On peut aussi accéder en profondeur aux composantes comme par exemple par la commande

```{r}
examen$note[7]
```

> i.  La méthode la plus simple pour créer un vecteur consiste à énumérer ses éléments à l'aide de la fonction `c()` :

```{r}
mesdonnees<-c(2.9, 3.4, 3.4, 3.7, 3.7, 2.8, 2.1, 2.5, 2.6)
mesdonnees
```

```{r}
couleurs<-c("bleu", "vert", "blanc", "noir", "jaune")
couleurs
```

> j.  On peut ôter des composantes d'un vecteur en indiquant entre crochets les indices précédés du signe négatif comme par exemple

```{r}
mesdonnees[-c(3:5)]
```

> k.  Finalement, le contenu de votre environnement de travail est affiché à l'aide de la fonction `ls()`.

```{r}
ls()
```

## Exercice 2

> La performance relative au processeur IBM 370/158-3 de 50 processeurs d'ordinateurs a été relevée. L'objet `cpus` contient les valeurs observées.

> a.  Construire un diagramme branche-et-feuilles, un histogramme et une boîte à moustaches des données observées à l'aide des commandes ci-dessous.

```{r}
stem(cpus)
```

```{r}
par(mfrow=c(1,2), pty="s")
hist(cpus, xlab="performance relative", ylab="fréquence", main="", 
     col="darkslategray4") 
boxplot(cpus, xlab="performance relative", col="darkslategray4", horizontal=T)
rug(cpus)
par(mfrow=c(1,1))
```

**Questions**

> 1.  Quels sont les effets de cette commande ?

`stem(cpus)` va produire un diagramme branche-et-feuilles des données contenues dans `cpus`.

`par(mfrow=c(1,2), pty="s")` ajuste les paramètres graphiques. En particulier, `mfrow=c(1,2)` indique que les graphiques qui suivent seront disposés en une ligne et deux colonnes (un à côté de l'autre). `pty="s"` rend le tracé carré.

`hist(cpus, xlab="performance relative", ylab="fréquence", main="", col="darkslategray4")` produit un histogramme de la performance relative des cpus. Les labels des axes x et y sont respectivement "performance relative" et "fréquence". La couleur du remplissage des barres est "darkslategray4".

`boxplot(cpus, xlab="performance relative", col="darkslategray4", horizontal=T)` produit une boîte à moustaches (boxplot) des données. Le graphique est affiché horizontalement (grâce à `horizontal=T`).

> 2.  Quel est l'effet de la fonction `rug()` ?

`rug(cpus)` ajoute de petites marques en bas de l'axe des x pour chaque donnée dans cpus. Cela permet de visualiser la densité des données le long de cet axe. En d'autres termes, elle montre où se trouvent les valeurs réelles dans le jeu de données.

`par(mfrow=c(1,1))` réinitialise les paramètres graphiques pour afficher un seul graphique à la fois.

> b.  Commenter la distribution des valeurs observées en se basant sur les graphiques de la Figure 1 : valeur(s) atypique(s), asymétrie.

Distribution: Nous pouvons observer sur l'histogramme une distribution asymétrique positive

Valeurs atypiques: Nous pouvons observer sur le boxplot qu'il y a 4 valeurs atypiques: 185, 370, 510 et 915.

> c.  Calculer la performance relative médiane et la performance relative moyenne des valeurs observées en utilisant les fonctions de R adéquates.

Avec la fonction `median()` nous calculons la performance médiane:

```{r}
# Calcul de la médiane
performance_mediane <- median(cpus)
print(paste("Performance relative médiane:", performance_mediane))
```

Avec la fonction `mean()` nous calculons la performance moyenne:

```{r}
# Calcul de la moyenne
performance_moyenne <- mean(cpus)
print(paste("Performance relative moyenne:", performance_moyenne))
```

> Est-il plus approprié d'utiliser la médiane ou la moyenne ?

Etant donné que nous avons des valeurs atypiques qui sont nettement plus élevées que la majorité des autres valeurs, elles peuvent avoir un effet significatif sur la moyenne, la rendant plus élevée qu'elle ne le serait autrement. Dans ce cas, la médiane pourrait être une meilleure mesure de la tendance centrale pour cet ensemble de données.

> d.  Déterminer le(s) mode(s) des valeurs observées à l'aide des commandes suivantes :

```{r}
n.cpus<-table(cpus)
as.numeric(names(n.cpus)[n.cpus==max(n.cpus)])
```

La commande ci-dessus permet de déterminer la valeur ou les valeurs qui apparaissent le plus souvent, c'est-à-dire le mode ou les modes de l'ensemble de données.

Les valeurs obtenues `24 36 66` indiquent que l'ensemble de données est multimodal. cela signifie qu'il a plusieurs "pics". Une distribution multimodale peut suggérer la présence de sous-groupes distincts.

> e.  Que fait la commande suivante ?

```{r}
summary(cpus)
```

La commande `summary(cpus)` fournit un aperçu statistique basique de l'objet cpus. Pour un vecteur comme `cpus`, cela retourne :

-   **Minimum**: La plus petite valeur de l'ensemble de données.
-   **1st Qu.**: Le premier quartile. 25% des données sont inférieures ou égales à cette valeur.
-   **Median**: La médiane. 50% des données sont inférieures ou égales à cette valeur.
-   **Mean**: La moyenne arithmétique de l'ensemble de données.
-   **3rd Qu.**: Le troisième quartile. 75% des données sont inférieures ou égales à cette valeur.
-   **Maximum**: La plus grande valeur de l'ensemble de données.

> f.  En effectuant aucun calcul, décrire l'effet sur la moyenne et sur la médiane des trois interventions suivantes :
>
>     1.  ajouter un processeur de performance relative 43;
>     2.  soustraire 9 à chaque valeur observée;
>     3.  diviser chaque observation par 3.

1.  **Ajouter un processeur de performance relative 43** :

    -   **Moyenne** : Elle diminuera, mais étant donné que 43 est proche de la moyenne initiale de 86.88, l'effet sur la moyenne sera minimal.

    -   **Médiane** : Étant donné que la médiane actuelle est de 42, l'ajout d'une valeur de 43 pourrait déplacer légèrement la médiane vers le haut, en fonction de la répartition exacte des données.

2.  **Soustraire 9 à chaque valeur observée** :

    -   **Moyenne** : En soustrayant un nombre constant de chaque observation, la moyenne sera également réduite de ce même montant..

    -   **Médiane** : La médiane sera également réduite de 9, car chaque valeur est diminuée de ce montant.

3.  **Diviser chaque observation par 3** :

    -   **Moyenne** : Si chaque observation est divisée par un nombre constant, la moyenne sera également divisée par ce nombre.

    -   **Médiane** : De même, la médiane sera divisée par 3.

> g.  Calculer l'écart-type des performances relatives une fois avec les valeurs atypiques et une fois sans en utilisant la fonction sd(). Les valeurs atypiques peuvent être déterminées à l'aide de la fonction `boxplot()` avec `plot=FALSE` comme argument.

1.  **Avec toutes les valeurs (incluant les atypiques) :**

```{r}
ecart_type_complet <- sd(cpus)
print(paste("Ecart type complet:", ecart_type_complet))
```

2.  **Sans les valeurs atypiques :**

D'abord, identifions les valeurs atypiques avec la fonction `boxplot()` :

```{r}
bp_stats <- boxplot(cpus, plot=FALSE)
atypiques <- bp_stats$out
print("Valeurs atypiques:")
atypiques
```

Maintenant, retirons ces valeurs atypiques de l'ensemble de données original :

```{r}
cpus_sans_atypiques <- cpus[!cpus %in% atypiques] 
```

Enfin, calculons l'écart-type pour cet ensemble sans les valeurs atypiques :

```{r}
print(paste("Ecart type sans valeurs atypiques:", sd(cpus_sans_atypiques)))
```

> Que constate-t-on ? L'écart-type est-il un indicateur robuste ?

Les valeurs atypiques ont un effet majeur sur l'écart-type, ce qui souligne la sensibilité de cet indicateur aux valeurs extrêmes. Une petite quantité de valeurs atypiques peut fausser la mesure de la dispersion, rendant l'écart-type beaucoup plus élevé qu'il ne le serait autrement. L'écart-type n'est pas un indicateur robuste en présence de valeurs atypiques, car il ne résiste pas bien à ces perturbations.

## Exercice 3

> Les étudiants suivant un cours de Probabilités et Statistique dans une école d'ingénierie ont passé l'examen de fin d'unité. Le cours était donné par le même professeur à étudiants répartis en deux groupes notés A et B. Les résultats obtenus sont contenus dans l'objet `examen`. On se demande si une différence significative existe entre les deux groupes à l'examen.

> a.  Tracer les boîtes à moustaches en parallèle en utilisant les commandes suivantes :

```{r}
lblue<-"#528B8B"
par(pty="s")
boxplot(note~groupe, data=examen, ylim=c(1,6), xlab="groupe", 
        varwidth=T, col=lblue, main="examen")
abline(h=4, lty=2)
```

> b.  Rajouter les bâtonnets des notes des étudiants des deux classes, sur le côté gauche des boîtes à moustaches pour la classe (side=2 comme argument de la fonction rug()) et sur le côté droite pour la classe (side=4 comme argument de la fonction rug()).

Rajout des bâtonnets:

```{r}
# Séparation des notes par groupe
note.A <- split(examen$note, examen$groupe)$A
note.B <- split(examen$note, examen$groupe)$B

# Affichage des boîtes à moustaches
lblue <- "#528B8B"
par(pty="s")
boxplot(note~groupe, data=examen, ylim=c(1,6), xlab="groupe", 
        varwidth=T, col=lblue, main="examen")
abline(h=4, lty=2)

# Ajout des bâtonnets pour le groupe A
rug(note.A, side=2)

# Ajout des bâtonnets pour le groupe B
rug(note.B, side=4)

```

> c.  En se basant sur la Figure 2, existe-t-il une différence significative entre les deux groupes à l'examen de fin d'unité ?

> d.  Observe-t-on sur les boîtes à moustaches une différence entre les dispersions des deux groupes ?

> e.  Calculer les écarts-types des deux groupes à l'aide des fonctions `by()` et `sd()`.

> En se basant sur les écarts-types, existe-t-il une différence en dispersion entre les deux groupes à l'examen de fin d'unité ?

> f.  Que peut-on déduire en comparant les conclusions établies en c., d. et e. ?

> g.  Un autre graphique pour étudier les éventuelles différences entre les deux groupes à l'examen de fin d'unité se trouve dans la Figure 3.

## Exercice 4

## Exercice 5

## Exercice 6
